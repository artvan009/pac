#!/usr/bin/env perl
use Mojolicious::Lite -signatures;

use Mojo::Util  qw(network_contains);
use NetAddr::IP ();
use Socket      qw(AF_INET AF_INET6 inet_ntop getaddrinfo unpack_sockaddr_in unpack_sockaddr_in6);

get
  '/' => {layout => 'pac'},
  'index';
get '/pac', [format => [qw(js)]], => 'pac';

post '/v1/gethostbyname' => sub ($c) {
  return $c->render(text => 'Host missing.', status => 400) unless my $host = $c->param('host');
  return $c->render(text => "Invalid host: $host", status => 400) unless $host =~ /[A-Za-z:\.]/;

  $c->res->headers->cache_control('max-age=600');
  return $c->render_later->host_to_ip_p($host)->then(sub ($addr) {
    return $c->render(text => "No IP found for $host", status => 400) unless $addr;
    return $c->render(text => $addr);
  })->catch(
    sub ($err, @) {
      return $c->render(text => exception_to_text($err), status => 500);
    }
  );
};

post '/v1/is-in-net' => sub ($c) {
  my ($ip, $net, $mask) = map { $c->param($_) } qw(ip net mask);
  return $c->render(text => 'IP or Net is missing.', status => 400)
    unless 2 == grep { $_ && $_ =~ /[:\.]/ } $ip, $net;
  return $c->render(text => 'Mask is invalid or missing.', status => 400)
    unless $mask and $mask =~ /^\d{1,3}$/;

  $c->res->headers->cache_control('max-age=600');
  return $c->render_later->host_to_ip_p($ip)->then(sub ($resolved) {
    $c->render(text => $resolved && network_contains("$net/$mask", $resolved) ? 1 : 0);
  })->catch(
    sub ($err, @) {
      $c->render(text => exception_to_text($err), status => 500);
    }
  );
};

get '/v1/template' => {template => 'template'};

helper host_to_ip_p => sub ($c, $host) {
  return Mojo::IOLoop->subprocess->run_p(sub (@) {
    local $SIG{ALRM} = sub { die 'Timeout!' };
    alarm 2;
    my ($err, @info) = getaddrinfo $host;
    return undef if $err;

    @info = grep { $_->{family} & (AF_INET6 | AF_INET) } @info;
    for my $item (@info) {
      $item->{pri} = $item->{family} == AF_INET6 ? 0 : 1;
      @$item{qw(port ip)}
        = $item->{family} == AF_INET6
        ? unpack_sockaddr_in6($item->{addr})
        : unpack_sockaddr_in($item->{addr});
      $item->{ip} = inet_ntop @$item{qw(family ip)};
    }

    # IPv4 before IPv6
    @info = sort { $b->{pri} <=> $a->{pri} } @info;

    return @info && $info[0]{ip} || undef;
  })->catch(
    sub ($err, @) {
      return $err =~ m!Timeout! ? undef : Mojo::Promise->reject($err);
    }
  );
};

if (my $env_base = $ENV{PROXYFORURL_X_REQUEST_BASE}) {
  $env_base = '' unless $env_base =~ m!^http!;
  hook before_dispatch => sub ($c) {
    return unless my $base = $env_base || $c->req->headers->header('X-Request-Base');
    $c->req->url->base(Mojo::URL->new($base));
  };
}

app->renderer->paths([$ENV{PROXYFORURL_TEMPLATES} || 'templates']);
app->static->paths([$ENV{PROXYFORURL_PUBLIC}      || 'public']);
app->start;

sub exception_to_text ($err) {
  $err =~ s!\sat\s\S+.*?line.*!!s;
  return $err;
}

__DATA__
@@ layouts/pac.html.ep
<!DOCTYPE html>
<html>
  <head>
    %= include 'partial/pac/head'
  </head>
  <body>
    %= content
  </body>
</html>
@@ partial/pac/head.html.ep
<title>Online proxy PAC file tester</title>
%= stylesheet '//unpkg.com/purecss@1.0.0/build/pure-min.css'
%= stylesheet begin
  form { max-width: 50em; margin: 3em auto; }
  textarea { height: 18em; }
  .footer { margin-top: 3em; font-size: 0.9em; }
  .footer, .footer a { color: #888; }
% end
@@ index.html.ep
%= form_for '', method => 'post', id => 'proxy_for_url', class => 'pure-form pure-form-stacked', begin
  <h1>Online proxy PAC file tester</h1>
  <p>
    <label for="pac_rules">PAC file</label>
    <textarea id="pac_rules" name="rules" class="pure-input-1"></textarea>
  </p>
  <p>
    <label for="pac_url">URL</label>
    %= text_field 'url', 'http://example.com', class => 'pure-input-1', id => 'pac_url', placeholder => 'http://example.com'
  </p>
  <p>
    <label for="pac_my_ip_address">Your IP address</label>
    %= text_field 'my_ip_address', 'http://example.com', class => 'pure-input-1', id => 'pac_my_ip_address', placeholder => 'http://example.com'
  </p>
  <p>
    <label for="pac_host">Host</label>
    %= text_field 'host', 'example.com', class => 'pure-input-1', id => 'pac_host'
  </p>
  <p>
    <button class="pure-button pure-button-primary">Find rule</button>
  </p>
  <label for="pac_rule_found">Rule</label>
  <input type="text" id="pac_rule_found" name="rule_found" readonly="readonly" class="pure-input-1">
  <pre class="pac-log hljs language-javascript"></pre>
  <p class="footer">
    Powered by <a href="//metacpan.org/pod/App::proxyforurl#DESCRIPTION">proxyforurl</a>.
  </p>
% end
%= javascript begin
%= include 'pac', format => 'js'
document.addEventListener('DOMContentLoaded', () => {
  if (window.ProxyForURL) return;
  window.proxyForURL = new ProxyForURL();
  window.proxyForURL.attach(document);
});
% end
@@ pac.js.ep
const PAC_FUNCTIONS = {
  alert: true,
  dateRange: false,
  dnsDomainIs: true,
  dnsDomainLevels: true,
  dnsResolve: true,
  isInNet: true,
  isPlainHostName: true,
  isResolvable: true,
  localHostOrDomainIs: true,
  myIpAddress: true,
  shExpMatch: true,
  timeRange: false,
  weekdayRange: false,
};

class ProxyForURL {
  attach(d) {
    this.form = d.querySelector('#proxy_for_url');
    if (!this.form) return console.warn('Could not find form#proxy_for_url');

    this.logEl = this.form.querySelector('.pac-log')
    if (!this.form) return console.warn('Could not find form .pac-log');
    this.logEl.style.display = 'none';

    this.myIpAddressInput = this.form.querySelector('[name=my_ip_address]');
    this.ruleFoundInput = this.form.querySelector('[name=rule_found]');
    this.rulesInput = this.form.querySelector('[name=rules]');
    if (!this.myIpAddressInput || !this.ruleFoundInput || !this.rulesInput) return console.error('Could not find all form fields');

    this.form.addEventListener('submit', (e) => [e.preventDefault(), this.findRule()]);
    this._init();
    console.info('ProxyForURL attached to form#proxy_for_url');
  }

  findRule() {
    const AsyncFunction = Object.getPrototypeOf(async function() {}).constructor;
    this._animate(true);

    try {
      const url = new URL(document.querySelector('#pac_url').value);
      this.log(null);
      this.log('// Looking for rule...');
      this.log('FindProxyForURL', [url, url.hostname], '...');

      this.findProxyForURL = this.rulesInput.value
          .replace(/function\s+FindProxyForURL[^{]+{/, '')
          .replace(/\}\s*$/, '');

      for (let func of Object.keys(PAC_FUNCTIONS)) {
        const re = new RegExp('\\b' + func + '\\s*\\(', 'g');
        this.findProxyForURL = this.findProxyForURL.replace(re, 'await this._wrap("' + func + '", ');
      }

      this.findProxyForURL = this.findProxyForURL.replace(/\b(new\s|document\.|window\.|cookie\b)/, 'ILLEGAL');

      const fn = new AsyncFunction('url', 'host', this.findProxyForURL).bind(this);
      fn(url.toString(), url.hostname).then(
        (rule) => (this.ruleFoundInput.value = rule),
        (err) => this.ruleFoundInput.value = String(err),
      ).finally(() => this._animate(false));
    } catch (err) {
      this._animate(false);
      this.ruleFoundInput.value = String(err);
      if (err.lineNumber) this.ruleFoundInput.value += ' at line ' + err.lineNumber;
      if (err.columnNumber) this.ruleFoundInput.value += ':' + err.columnNumber;
      this.logEl.innerHTML = this.findProxyForURL;
      throw err;
    }
  }

  log(msg, args, res) {
    this.logEl.style.display = msg === null ? 'none' : 'block';
    if (msg === null) return this._log = this.logEl.textContent = '';
    if (!args) return this.logEl.textContent += msg + '\n';

    const prefix = PAC_FUNCTIONS[msg] === false ? '// ' : '';
    args = JSON.stringify(args).replace(/^\[/, '(').replace(/]$/, ')');
    if (res != '...') res = JSON.stringify(res)
    this._log += prefix + msg + args + ' = ' + res + ';\n';
    this.logEl.innerHTML = this._log;
  }

  async alert() {
    return true;
  }

  async dateRange() {
    return true;
  }

  async dnsDomainIs(host, domain) {
    const hostParts = host.split('.');
    const domainParts = domain.split('.');
    if (hostParts.length < domainParts.length) return false;

    while (domainParts.length) {
      const p = domainParts.pop();
      if (!p.length) continue;
      if (p != hostParts.pop()) return false;
    }

    return true;
  }

  async dnsDomainLevels(host) {
    const m = host.match(/\./g);
    return m ? m.length : 0;
  }

  async dnsResolve(host) {
    const body = new FormData();
    body.append('host', host);
    const res = await fetch('/v1/gethostbyname', {method: 'POST', body});
    const text = await res.text();
    if (res.status >= 500) throw 'dnsResolve() FAIL ' + (text || res.status);
    return text;
  }

  async isInNet(ip, net, mask) {
    // Ex: Turn 255.255.255.0 into 24
    if (mask.match(/\./)) mask = Math.round(mask.split('.').reduce((c, o) => c - Math.log2(256 - o), 32));

    const body = new FormData();
    body.append('ip', ip);
    body.append('net', net);
    body.append('mask', mask);
    const res = await fetch('/v1/is-in-net', {method: 'POST', body});
    const text = await res.text();
    if (res.status >= 500) throw 'isInNet() FAIL ' + (text || res.status);
    return parseInt(text, 10) ? true : false;
  }

  async isResolvable(host) {
    return await this.dnsResolve(host) ? true : false;
  }

  async isPlainHostName(str) {
    return str.match(/\./) ? false : true;
  }

  async localHostOrDomainIs(host, str) {
    return str.match(/^\./) ? dnsDomainIs(host, str) : host == str ? true : host == host.split('.')[0];
  }

  async myIpAddress() {
    return this.myIpAddressInput.value || this.remoteAddress || '127.0.0.1';
  }

  async shExpMatch(host, re) {
    return host.match(new RegExp(re.replace(/\*/, '.*?'), 'i')) ? true : false;
  }

  async timeRange() {
    return true;
  }

  async weekdayRange() {
    return true;
  }

  _animate(start) {
    const method = start ? 'add' : 'remove';
    setTimeout(() => {
      this.form.querySelector('button').classList[method]('animation-blink');
      this.ruleFoundInput.classList[method]('animation-blink');
    }, (start ? 1 : 350));
  }

  async _init() {
    const res = await fetch('/v1/template');
    const text = await res.text();

    if (!this.rulesInput.value) this.rulesInput.value = text;
    const yourIp = text.match(/Your IP: (\S+)/) || [];
    this.remoteAddress = yourIp[1] || '127.0.0.1';
    this.myIpAddressInput.placeholder = this.remoteAddress;
    this.myIpAddressInput.value = this.remoteAddress;
  }

  async _wrap(func) {
    const args = [].slice.call(arguments, 1);
    const res = await this[func].apply(this, args);
    this.log(func, args, res);
    return res;
  }
}
@@ template.html.ep
// Your IP: <%= $c->tx->remote_address %>
function FindProxyForURL(url, host) {
  // our local URLs from the domains below example.com don't need a proxy:
  if (shExpMatch(host, "*.example.com")) return "DIRECT";
  if (isPlainHostName(host)) return "DIRECT";
  if (localHostOrDomainIs(host, "www.example.com")) return "PROXY local.proxy:8080";
  if (!isResolvable(host)) return "SOCKS4 example.com:1080";
  if (dnsDomainLevels(host) == 4) return "SOCKS4 example.com:1081";

  alert("Checking other rules...");
  alert(myIpAddress());

  // URLs within this network are accessed through
  // port 8080 on fastproxy.example.com:
  if (isInNet(host, "10.0.0.0", "255.255.248.0")) return "PROXY fastproxy.example.com:8080";

  if (dnsDomainIs(host, "example.com")) return "PROXY proxy2.example.com:8888";

  // All other requests go through port 8080 of proxy.example.com.
  // should that fail to respond, go directly to the WWW:
  return "PROXY proxy.example.com:8080; DIRECT";
}
